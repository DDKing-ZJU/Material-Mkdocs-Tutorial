---
    title: HideNothing
    date: 2023年7月11日
    tags: 算法
    cover: https://img.ddking.site/image/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.jpg
---
# Page 2
<img src = "https://img.ddking.site/image/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.jpg"></img>

栈和队列是数据结构中比较基础的两个，它们遵循两个经典的原则，就是FILO(First In Last Out 先进后出) 和 FIFO(First In First Out 先进先出)。而在它们前面加上“单调”两个字，就说明它们具有“单调”的特性，也就是在它们中的元素是按照一定的大小顺序进行排列的。
***
$\LaTeX$

## 模拟过程
### 单调栈
现在我们有一个数组：5,1,2,8,0,9,4,3,6,7。
我们普通地遍历数组，尝试把元素放在栈里面。假设这个栈是单调递增的。

|   i   | 遍历到的元素 |              描述              | 操作后栈中的元素 |
| :---: | :----------: | :----------------------------: | :--------------: |
|   0   |      5       |            正常入栈            |        5         |
|   1   |      1       |   为保证单调性，5出栈，1入栈   |        1         |
|   2   |      2       |            正常入栈            |       1,2        |
|   3   |      8       |            正常入栈            |      1,2,8       |
|   4   |      0       | 为保证单调性，1,2,8出栈，0入栈 |        0         |
|   5   |      9       |            正常入栈            |       0,9        |
|   6   |      4       |   为保证单调性，9出栈，4入栈   |       0,4        |
|   7   |      3       |   为保证单调性，4出栈，3入栈   |       0,3        |
|   8   |      6       |            正常入栈            |      0,3,6       |
|   9   |      7       |            正常入栈            |     0,3,6,7      |
   
   
我们仔细观察栈中的各元素，我们可以很容易地观察到，我们如果遍历到一个元素，栈中的元素是一个单调递增的序列（这很显然）。我们知道，这个单调递增的序列的生成方式是正向的，如果我们逆向地去生成这个序列，我们可以很明显地观察到他的生成方式其实是向左不断地寻找更小元素。所以说，**单调栈可以用来寻找某一方向的最近的更小（更大）元素**。

### 单调队列
还是同样的数组：5,1,2,8,0,9,4,3,6,7。

假如我们用只用队头进行元素的出队，也就是这个队列是单向的。
因为要保证单调性，用队尾来比较，那么我们得到的结果就是一个从该元素开始的连续单调子序列。然而这并没有发挥队列的优势，更像用大炮打蚊子。这其实是因为我们没有充分发挥队头指针的优势。

**设计规则** 
我们需要设计一个规则，让队头在某个规则下按部就班地离队。最简单的方法就是设计一个“存活时间”，也就是让这个元素在入队之后存活若干个遍历循环，然后将其自动踢出。借助一篇网络博客的比喻，就像给各个元素设置“毕业时间”。

注意：之前提到队列是FIFO的，然而单调队列更像套了单调栈皮的队列，队列的先进先出体现在“存活时间”上，其它流程与单调栈并无区别。

那么，我们假设这个存活时间是三轮，于是我们进行遍历模拟，可以得到如下结果——

|   i   | 遍历到的元素 |                      描述                      | 操作后队列中的元素[值+存活时间] |
| :---: | :----------: | :--------------------------------------------: | :-----------------------------: |
|   0   |      5       |                    正常入队                    |              5(3)               |
|   1   |      1       |            保证单调性，5从后面出队             |              1(3)               |
|   2   |      2       |                    正常入队                    |            1(2),2(3)            |
|   3   |      8       |                    正常入队                    |         1(1),2(2),8(3)          |
|   4   |      0       |        保证单调性，所有元素均从后面出队        |              0(3)               |
|   5   |      9       |                    正常入队                    |            0(2),9(3)            |
|   6   |      4       |            保证单调性，9从后面出队             |            0(1),4(3)            |
|   7   |      3       | 0元素死亡，从前面出队；保证单调性，4从后面出队 |              3(3)               |
|   8   |      6       |                    正常入队                    |            3(2),6(3)            |
|   9   |      7       |                    正常入队                    |         3(1),6(2),7(3)          |
   

我们将队列的元素与单调栈模拟出来的结果进行比较，可以发现，大体上，它们并没有很多差异，而且单调队列的结果都是单调栈结果的子序列。这本质上是给单调栈模型加了个限制：**如果说单调栈可以用来寻找某一方向的最近的更小（更大）元素，那么单调队列会在这个基础上再加上一个条件——一定的范围内**。这个范围就是“存活时间”。
***
## 实战演练

#### 单调栈
<a href="https://leetcode.cn/problems/next-greater-element-i/">leetcode 496.下一个更大元素（单调栈解法）</a>
<a href="https://leetcode.cn/problems/daily-temperatures/">leetcode 739. 每日温度（单调栈详解）</a>
<a href="https://leetcode.cn/problems/next-greater-element-ii/">leetcode 503. 下一个更大元素Ⅱ（单调栈解法详解）</a>
<a href="https://leetcode.cn/problems/online-stock-span/">leetcode 901. 股票价格跨度（单调栈解法详解）</a>

#### 单调队列
<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">leetcode 239. 滑动窗口最大值</a>